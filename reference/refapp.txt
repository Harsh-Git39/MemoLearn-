// app.js - Handles both background events and content injection

const API_BASE = 'http://localhost:3000';

// ============================================
// BACKGROUND LOGIC (Service Worker Context)
// ============================================

if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessage) {
  
  // Listen for messages from content script part
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    
    // Match query with backend
    if (request.action === 'matchQuery') {
      fetch(`${API_BASE}/match`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: request.query })
      })
      .then(res => res.json())
      .then(data => sendResponse({ matches: data }))
      .catch(err => sendResponse({ error: err.message }));
      
      return true; // Async response
    }
    
    // Save query to backend
    if (request.action === 'saveQuery') {
      fetch(`${API_BASE}/save`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: request.query,
          answer: request.answer
        })
      })
      .then(res => res.json())
      .then(data => sendResponse({ success: true }))
      .catch(err => sendResponse({ error: err.message }));
      
      return true;
    }
    
    // Delete query
    if (request.action === 'deleteQuery') {
      fetch(`${API_BASE}/delete`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: request.id })
      })
      .then(res => res.json())
      .then(data => sendResponse({ success: true }))
      .catch(err => sendResponse({ error: err.message }));
      
      return true;
    }
  });
  
  // Listen for tab updates (new searches)
  chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete' && tab.url) {
      const isSearchPage = tab.url.includes('google.com/search') || 
                          tab.url.includes('bing.com/search');
      
      if (isSearchPage) {
        // Extract query from URL
        const url = new URL(tab.url);
        const query = url.searchParams.get('q');
        
        if (query) {
          // Send to content script
          chrome.tabs.sendMessage(tabId, {
            action: 'checkQuery',
            query: query
          });
        }
      }
    }
  });
}

// ============================================
// CONTENT SCRIPT LOGIC (Page Context)
// ============================================

if (typeof window !== 'undefined' && window.location) {
  
  // Extract current search query from page
  function getCurrentQuery() {
    const params = new URLSearchParams(window.location.search);
    return params.get('q') || '';
  }
  
  // Initialize on page load
  function init() {
    const query = getCurrentQuery();
    if (query) {
      checkForMatches(query);
    }
  }
  
  // Check if query has matches
  function checkForMatches(query) {
    chrome.runtime.sendMessage({
      action: 'matchQuery',
      query: query
    }, (response) => {
      if (response && response.matches && response.matches.length > 0) {
        showPopup(response.matches);
      }
    });
  }
  
  // Inject popup into page
  function showPopup(matches) {
    // Fetch rendered EJS from backend
    fetch(`${API_BASE}/popup`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ matches: matches })
    })
    .then(res => res.text())
    .then(html => {
      // Remove existing popup if any
      const existing = document.getElementById('memolearn-popup');
      if (existing) existing.remove();
      
      // Create popup
      const popup = document.createElement('div');
      popup.id = 'memolearn-popup';
      popup.innerHTML = html;
      
      // Inject beside search results
      const container = document.querySelector('#search') || 
                       document.querySelector('#b_results') || 
                       document.body;
      container.insertAdjacentElement('afterbegin', popup);
      
      // Attach listeners
      attachEventListeners();
    });
  }
  
  // Handle user actions
  function attachEventListeners() {
    // Pin button
    document.querySelectorAll('.memolearn-pin').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const query = e.target.dataset.query;
        const answer = e.target.dataset.answer;
        
        chrome.runtime.sendMessage({
          action: 'saveQuery',
          query: query,
          answer: answer
        }, (response) => {
          if (response.success) {
            alert('Saved to MemoLearn!');
          }
        });
      });
    });
    
    // Copy button
    document.querySelectorAll('.memolearn-copy').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const answer = e.target.dataset.answer;
        navigator.clipboard.writeText(answer);
        alert('Copied to clipboard!');
      });
    });
    
    // Delete button
    document.querySelectorAll('.memolearn-delete').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const id = e.target.dataset.id;
        
        chrome.runtime.sendMessage({
          action: 'deleteQuery',
          id: id
        }, (response) => {
          if (response.success) {
            // Remove from DOM
            e.target.closest('.memolearn-item').remove();
          }
        });
      });
    });
    
    // Close button
    const closeBtn = document.querySelector('.memolearn-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        document.getElementById('memolearn-popup').remove();
      });
    }
  }
  
  // Listen for messages from background
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'checkQuery') {
      checkForMatches(request.query);
    }
  });
  
  // Run on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
}
